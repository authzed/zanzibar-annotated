{"version":3,"file":"1-6ee99c94.js","sources":["../src/versions/1.ts"],"sourcesContent":["import { cyrb53 } from '../util/cyrb53';\nimport { fromNumber } from '../util/base64';\n\n// See docs/spec/v1.md for what this code implements.\n// It must also be compatible with docs/spec/v0.md.\n\n// See https://dom.spec.whatwg.org/#interface-node\n// The minifier isn't smart enough to know this, so do it ourselves and save\n// the, uh 26 bytes...\nconst TEXT_NODE = 3;\n// Same as above, see https://dom.spec.whatwg.org/#interface-nodefilter\nconst NODEFILTER_SHOW_TEXT = 0x04;\n\nfunction hashNode(n: Text): string {\n  return fromNumber(cyrb53(n.wholeText));\n}\n\n// Take a range, and return a new range containing the same text, but ensuring\n// that the start and end are both non-whitespace-only text nodes.\nfunction normalizeRange(range: Range) {\n  // We start off by picking start and end nodes. If the start node is a text\n  // node, we can just use it as is. If it's a element node, though, we need to\n  // use the offset to figure out which child node is the one that's actually\n  // selected.\n  //\n  // There's a additional hiccup that the offsets used by Range represent the\n  // spaces in between child nodes, while the TreeWalker API operates on the\n  // nodes directly. Because of this, we need to keep track of whether the\n  // selected text starts/ends before or after the start/end node. The\n  // startOffset/endOffset variables do double duty in this regard — if the\n  // startNode/endNode is a text node, the startOffset/endOffset is a text\n  // offset, but if the startNode/endNode is a element node, they represent\n  // whether the selection starts/ends before the node (0) or after the node\n  // (1).\n\n  const makeNodeAndOffset = (initNode: Node, initOffset: number): [Node, number] => {\n    let node, offset;\n    if (initNode.nodeType == TEXT_NODE || initNode.childNodes.length == 0) {\n      node = initNode;\n      offset = initOffset;\n    } else {\n      node = initNode.childNodes[Math.min(initOffset, initNode.childNodes.length - 1)];\n      if (node.nodeType == TEXT_NODE) {\n        offset = (initOffset == initNode.childNodes.length) ? (node as Text).wholeText.length : 0;\n      } else {\n        offset = (initOffset == initNode.childNodes.length) ? 1 : 0;\n      }\n    }\n    return [node, offset];\n  };\n\n  const [startNode, startOffset] = makeNodeAndOffset(range.startContainer, range.startOffset);\n  const [endNode, endOffset] = makeNodeAndOffset(range.endContainer, range.endOffset);\n\n  const newRange = new Range();\n  const treeWalker = document.createTreeWalker(range.commonAncestorContainer);\n  // stages:\n  // 0 = Looking for startNode.\n  // 1 = startNode found, but it wasn't a non-empty text node — looking for a\n  //     non-empty text node.\n  // 2 = Looking for endNode.\n  let stage = 0;\n  let node: Node | null = treeWalker.currentNode;\n  let prevEndNode = endNode;\n  while (node) {\n    if (stage == 0 && node == startNode) {\n      if (node.nodeType != TEXT_NODE && startOffset != 0) {\n        node = treeWalker.nextNode();\n        if (!node) {\n          return null;\n        }\n      }\n      stage = 1;\n    }\n    if (node.nodeType == TEXT_NODE && (node as Text).wholeText.trim() != '') {\n      if (stage == 1) {\n        newRange.setStart(node, (node == startNode) ? startOffset : 0);\n        stage = 2;\n      }\n      if (stage == 2) {\n        prevEndNode = newRange.endContainer;\n        newRange.setEnd(node, (node as Text).wholeText.length);\n      }\n    }\n    if (stage == 2 && node == endNode) {\n      if (node.nodeType == TEXT_NODE && (node as Text).wholeText.trim() != '') {\n        newRange.setEnd(node, endOffset);\n        return newRange;\n      }\n      if (node == newRange.endContainer && endOffset == 0) {\n        newRange.setEnd(prevEndNode, (prevEndNode as Text).wholeText.length);\n      }\n      return newRange;\n    }\n    node = treeWalker.nextNode();\n  }\n\n  return null;\n}\n\nexport function selectionToFragment(selection: Selection): string {\n  type HashNodeOffset = [string, Text, number];\n  type DupeData = [boolean[], number, number];\n  const ranges: [HashNodeOffset, HashNodeOffset, DupeData][] = [];\n  for (let i = 0; i < selection.rangeCount; i++) {\n    const range = normalizeRange(selection.getRangeAt(i));\n    if (range && !range.collapsed) {\n      const [startNode, endNode] = [range.startContainer, range.endContainer];\n      if (startNode.nodeType == TEXT_NODE && endNode.nodeType == TEXT_NODE) {\n        ranges.push([\n          [hashNode(startNode as Text), startNode as Text, range.startOffset],\n          [hashNode(endNode as Text), endNode as Text, range.endOffset],\n          [[], 0, 0],\n        ]);\n      }\n    }\n  }\n\n  if (ranges.length == 0) {\n    return '';\n  }\n\n  const walk = document.createTreeWalker(document.body, NODEFILTER_SHOW_TEXT);\n  let node;\n  while (node = walk.nextNode() as Text) { // eslint-disable-line no-cond-assign\n    const hash = hashNode(node);\n    for (const [[startHash, startNode], [endHash, endNode], dupes] of ranges) {\n      if (startNode == node) {\n        dupes[1] = dupes[0].length;\n      }\n      if (endNode == node) {\n        dupes[2] = dupes[0].length;\n      }\n      if (startHash == hash) {\n        dupes[0].push(true);\n      } else if (endHash == hash) {\n        dupes[0].push(false);\n      }\n    }\n  }\n\n  const fragmentParts = ranges.map(([[startHash, , startOffset], [endHash, , endOffset], [dupes, startDupeOffset, endDupeOffset]]) => {\n    let fragmentPart;\n    if (startHash == endHash) {\n      fragmentPart= `${startHash}:${startOffset}:${endOffset}`;\n    } else {\n      fragmentPart= `${startHash}:${startOffset}.${endHash}:${endOffset}`;\n    }\n    if (new Set(dupes).size != dupes.length) {\n      const dupesString = dupes.map(x => x ? 's' : 'e').join('');\n      fragmentPart += `~${dupesString}~${startDupeOffset}~${endDupeOffset}`;\n    }\n    return fragmentPart;\n  });\n\n  return `#1${fragmentParts.join()}`;\n}\n\nfunction getRangeFromFragmentPart(fragmentPart: string): Range {\n  const [hashOffsetFragmentPart, dupeString, dupeStartOffset, dupeEndOffset] = fragmentPart.split('~');\n  const split = hashOffsetFragmentPart.split('.').map((x) => x.split(':'));\n  let startHash, startOffset, endHash, endOffset;\n  if (split.length == 1) {\n    [[startHash, startOffset, endOffset]] = split;\n    endHash = startHash;\n  } else {\n    [[startHash, startOffset], [endHash, endOffset]] = split;\n  }\n  [startOffset, endOffset] = [startOffset, endOffset].map(parseFloat);\n\n  // the boolean represents whether it's a start node (true) or end node (false)\n  const nodes: [Text, boolean][] = [];\n\n  const walk = document.createTreeWalker(document.body, NODEFILTER_SHOW_TEXT, null);\n  let node, numEndNodes = 0;\n  while (node = walk.nextNode() as Text) { // eslint-disable-line no-cond-assign\n    const hash = hashNode(node);\n    if (hash == startHash) {\n      nodes.push([node, true]);\n    } else if (hash == endHash) {\n      nodes.push([node, false]);\n      numEndNodes++;\n    }\n  }\n\n  let startNode, endNode;\n\n  if (dupeString && nodes.map(n => n[1] ? 's' : 'e').join('') == dupeString) {\n    startNode = nodes[parseInt(dupeStartOffset)];\n    endNode = nodes[parseInt(dupeEndOffset)];\n  }\n\n  if (!startNode || !endNode) {\n    if (startHash == endHash) {\n      startNode = nodes[0];\n      endNode = startNode;\n    } else {\n      // If there's more than one end node, start with the start node.  This\n      // ensures that in cases where both nodes are ambiguous, the first pair is\n      // selected.\n      const anchorNodeType = numEndNodes > 1;\n      const anchorNodeIndex = nodes.findIndex(e => e[1] == anchorNodeType);\n      startNode = nodes[anchorNodeType ? anchorNodeIndex : anchorNodeIndex - 1];\n      endNode = nodes[anchorNodeType ? anchorNodeIndex + 1: anchorNodeIndex];\n    }\n  }\n\n  const range = new Range();\n  if (startNode && endNode) {\n    range.setStart(startNode[0], startOffset);\n    range.setEnd(endNode[0], endOffset);\n  }\n  return range;\n}\n\nexport function fragmentToRangeList(fragment: string): Range[] {\n  return fragment.replace(/^1\\.?/gm, '').split(',').map(getRangeFromFragmentPart);\n}\n"],"names":["hashNode","n","fromNumber","cyrb53","wholeText","normalizeRange","range","makeNodeAndOffset","initNode","initOffset","node","offset","nodeType","childNodes","length","Math","min","startNode","startOffset","startContainer","endNode","endOffset","endContainer","newRange","Range","treeWalker","document","createTreeWalker","commonAncestorContainer","stage","currentNode","prevEndNode","nextNode","trim","setStart","setEnd","selectionToFragment","selection","ranges","i","rangeCount","getRangeAt","collapsed","push","walk","body","hash","startHash","endHash","dupes","map","startDupeOffset","endDupeOffset","fragmentPart","Set","size","x","join","getRangeFromFragmentPart","hashOffsetFragmentPart","dupeString","dupeStartOffset","dupeEndOffset","split","parseFloat","nodes","numEndNodes","parseInt","anchorNodeType","anchorNodeIndex","findIndex","e","fragmentToRangeList","fragment","replace"],"mappings":"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"}