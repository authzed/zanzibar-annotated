{"version":3,"file":"deeplinks.js","sources":["../src/util/base64.ts","../src/util/cyrb53.ts","../src/versions/2.ts","../src/deeplinks.ts"],"sourcesContent":["// https://stackoverflow.com/questions/6213227/fastest-way-to-convert-a-number-to-radix-64-in-javascript/6573119#6573119\n// modified for typescript/general modernization/aesthetics/etc\n// the alphabet has also been changed to use more reasonable characters for a url.\n\nconst _rixits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_';\n\n// This cannot handle negative numbers and only works on the integer part,\n// discarding the fractional part. Doing better means deciding on whether\n// you're just representing the subset of javascript numbers of\n// twos-complement 32-bit integers or going with base-64 representations for\n// the bit pattern of the underlying IEEE floating-point number, or\n// representing the mantissae and exponents separately, or some other\n// possibility. For now, bail\nexport function fromNumber(number: number): string {\n  if (isNaN(number) || number === Infinity || number < 0) {\n    throw 'invalid input';\n  }\n\n  let result = '', rixit; // like 'digit', only in some non-decimal radix\n  number = Math.floor(number);\n  for (;;) {\n    rixit = number % 64;\n    result = _rixits.charAt(rixit) + result;\n    number = Math.floor(number / 64);\n\n    if (number == 0) { break; }\n  }\n  return result;\n}\n\nexport function toNumber(string: string): number {\n  let result = 0;\n  const rixits = string.split('');\n  for (let e = 0; e < rixits.length; e++) {\n    result = (result * 64) + _rixits.indexOf(rixits[e]);\n  }\n  return result;\n}\n","// this function has been taken from the stack overflow post linked below, with\n// the modification that the seed has been removed, since it was unused\n// anyways.\n//\n// https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480\n\nexport const cyrb53 = function(str: string): number {\n  let h1 = 0xdeadbeef, h2 = 0x41c6ce57;\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i);\n    h1 = Math.imul(h1 ^ ch, 2654435761);\n    h2 = Math.imul(h2 ^ ch, 1597334677);\n  }\n  h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);\n  h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);\n  return 4294967296 * (2097151 & h2) + (h1>>>0);\n};\n","import { fromNumber, toNumber } from '../util/base64';\nimport { cyrb53 } from '../util/cyrb53';\n\n// See docs/spec/v2.md for what this code implements.\n\n// See https://dom.spec.whatwg.org/#interface-node\n// The minifier isn't smart enough to know this, so do it ourselves and save\n// the, uh 26 bytes...\nconst TEXT_NODE = 3;\n// Same as above, see https://dom.spec.whatwg.org/#interface-nodefilter\nconst NODEFILTER_SHOW_TEXT = 0x04;\n\nfunction hashNode(n: Text): string {\n  return fromNumber(cyrb53(n.wholeText.trim()));\n}\n\nfunction countLeadingWhitespace(node: Text): number {\n  return node.wholeText.length - node.wholeText.trimStart().length;\n}\n\n// Take a range, and return a new range containing the same text, but ensuring\n// that the start and end are both non-whitespace-only text nodes.\nfunction normalizeRange(range: Range) {\n  // We start off by picking start and end nodes. If the start node is a text\n  // node, we can just use it as is. If it's a element node, though, we need to\n  // use the offset to figure out which child node is the one that's actually\n  // selected.\n  //\n  // There's a additional hiccup that the offsets used by Range represent the\n  // spaces in between child nodes, while the TreeWalker API operates on the\n  // nodes directly. Because of this, we need to keep track of whether the\n  // selected text starts/ends before or after the start/end node. The\n  // startOffset/endOffset variables do double duty in this regard — if the\n  // startNode/endNode is a text node, the startOffset/endOffset is a text\n  // offset, but if the startNode/endNode is a element node, they represent\n  // whether the selection starts/ends before the node (0) or after the node\n  // (1).\n\n  const makeNodeAndOffset = (initNode: Node, initOffset: number): [Node, number] => {\n    let node, offset;\n    if (initNode.nodeType == TEXT_NODE || initNode.childNodes.length == 0) {\n      node = initNode;\n      offset = initOffset;\n    } else {\n      node = initNode.childNodes[Math.min(initOffset, initNode.childNodes.length - 1)];\n      if (node.nodeType == TEXT_NODE) {\n        offset = (initOffset == initNode.childNodes.length) ? (node as Text).wholeText.length : 0;\n      } else {\n        offset = (initOffset == initNode.childNodes.length) ? 1 : 0;\n      }\n    }\n    return [node, offset];\n  };\n\n  const [startNode, startOffset] = makeNodeAndOffset(range.startContainer, range.startOffset);\n  const [endNode, endOffset] = makeNodeAndOffset(range.endContainer, range.endOffset);\n\n  const newRange = new Range();\n  const treeWalker = document.createTreeWalker(range.commonAncestorContainer);\n  // stages:\n  // 0 = Looking for startNode.\n  // 1 = startNode found, but it wasn't a non-empty text node — looking for a\n  //     non-empty text node.\n  // 2 = Looking for endNode.\n  let stage = 0;\n  let node: Node | null = treeWalker.currentNode;\n  let prevEndNode = endNode;\n  while (node) {\n    if (stage == 0 && node == startNode) {\n      if (node.nodeType != TEXT_NODE && startOffset != 0) {\n        node = treeWalker.nextNode();\n        if (!node) {\n          return null;\n        }\n      }\n      stage = 1;\n    }\n    if (node.nodeType == TEXT_NODE && (node as Text).wholeText.trim() != '') {\n      if (stage == 1) {\n        newRange.setStart(node, (node == startNode) ? startOffset : 0);\n        stage = 2;\n      }\n      if (stage == 2) {\n        prevEndNode = newRange.endContainer;\n        newRange.setEnd(node, (node as Text).wholeText.length);\n      }\n    }\n    if (stage == 2 && node == endNode) {\n      if (node.nodeType == TEXT_NODE && (node as Text).wholeText.trim() != '') {\n        newRange.setEnd(node, endOffset);\n        return newRange;\n      }\n      if (node == newRange.endContainer && endOffset == 0) {\n        newRange.setEnd(prevEndNode, (prevEndNode as Text).wholeText.length);\n      }\n      return newRange;\n    }\n    node = treeWalker.nextNode();\n  }\n\n  return null;\n}\n\nexport function selectionToFragment(selection: Selection): string {\n  type HashNodeOffset = [string, Text, string];\n  type DupeData = [boolean[], number, number];\n  const ranges: [HashNodeOffset, HashNodeOffset, DupeData][] = [];\n  for (let i = 0; i < selection.rangeCount; i++) {\n    const range = normalizeRange(selection.getRangeAt(i));\n    if (range && !range.collapsed) {\n      const [startNode, endNode] = [range.startContainer, range.endContainer];\n      if (startNode.nodeType == TEXT_NODE && endNode.nodeType == TEXT_NODE) {\n        ranges.push([\n          [hashNode(startNode as Text), startNode as Text, fromNumber(Math.max(range.startOffset - countLeadingWhitespace(startNode as Text), 0))],\n          [hashNode(endNode as Text), endNode as Text, fromNumber(Math.max(Math.min(range.endOffset - countLeadingWhitespace(endNode as Text), (endNode as Text).wholeText.trim().length), 0))],\n          [[], 0, 0],\n        ]);\n      }\n    }\n  }\n\n  if (ranges.length == 0) {\n    return '';\n  }\n\n  const walk = document.createTreeWalker(document.body, NODEFILTER_SHOW_TEXT);\n  let node;\n  while (node = walk.nextNode() as Text) { // eslint-disable-line no-cond-assign\n    const hash = hashNode(node);\n    for (const [[startHash, startNode], [endHash, endNode], dupes] of ranges) {\n      if (startNode == node) {\n        dupes[1] = dupes[0].length;\n      }\n      if (endNode == node) {\n        dupes[2] = dupes[0].length;\n      }\n      if (startHash == hash) {\n        dupes[0].push(true);\n      } else if (endHash == hash) {\n        dupes[0].push(false);\n      }\n    }\n  }\n\n  const fragmentParts = ranges.map(([[startHash, , startOffset], [endHash, , endOffset], [dupes, startDupeOffset, endDupeOffset]]) => {\n    let fragmentPart;\n    if (startHash == endHash) {\n      fragmentPart= `${startHash}:${startOffset}:${endOffset}`;\n    } else {\n      fragmentPart= `${startHash}:${startOffset}.${endHash}:${endOffset}`;\n    }\n    if (new Set(dupes).size != dupes.length) {\n      const dupesString = dupes.map(x => x ? 's' : 'e').join('');\n      fragmentPart += `~${dupesString}~${fromNumber(startDupeOffset)}~${fromNumber(endDupeOffset)}`;\n    }\n    return fragmentPart;\n  });\n\n  return `#2${fragmentParts.join()}`;\n}\n\nfunction getRangeFromFragmentPart(fragmentPart: string): Range {\n  const [hashOffsetFragmentPart, dupeString, dupeStartOffset, dupeEndOffset] = fragmentPart.split('~');\n  const split = hashOffsetFragmentPart.split('.').map((x) => x.split(':'));\n  let startHash, startOffset, endHash, endOffset;\n  if (split.length == 1) {\n    [[startHash, startOffset, endOffset]] = split;\n    endHash = startHash;\n  } else {\n    [[startHash, startOffset], [endHash, endOffset]] = split;\n  }\n  [startOffset, endOffset] = [startOffset, endOffset].map(toNumber);\n\n  // the boolean represents whether it's a start node (true) or end node (false)\n  const nodes: [Text, boolean][] = [];\n\n  const walk = document.createTreeWalker(document.body, NODEFILTER_SHOW_TEXT, null);\n  let node, numEndNodes = 0;\n  while (node = walk.nextNode() as Text) { // eslint-disable-line no-cond-assign\n    const hash = hashNode(node);\n    if (hash == startHash) {\n      nodes.push([node, true]);\n    } else if (hash == endHash) {\n      nodes.push([node, false]);\n      numEndNodes++;\n    }\n  }\n\n  let startNode, endNode;\n\n  if (dupeString && nodes.map(n => n[1] ? 's' : 'e').join('') == dupeString) {\n    startNode = nodes[toNumber(dupeStartOffset)];\n    endNode = nodes[toNumber(dupeEndOffset)];\n  }\n\n  if (!startNode || !endNode) {\n    if (startHash == endHash) {\n      startNode = nodes[0];\n      endNode = startNode;\n    } else {\n      // If there's more than one end node, start with the start node.  This\n      // ensures that in cases where both nodes are ambiguous, the first pair is\n      // selected.\n      const anchorNodeType = numEndNodes > 1;\n      const anchorNodeIndex = nodes.findIndex(e => e[1] == anchorNodeType);\n      startNode = nodes[anchorNodeType ? anchorNodeIndex : anchorNodeIndex - 1];\n      endNode = nodes[anchorNodeType ? anchorNodeIndex + 1: anchorNodeIndex];\n    }\n  }\n\n  const range = new Range();\n  if (startNode && endNode) {\n    range.setStart(startNode[0], Math.min(startOffset + countLeadingWhitespace(startNode[0]), startNode[0].wholeText.length));\n    range.setEnd(endNode[0], Math.min(endOffset + countLeadingWhitespace(endNode[0]), endNode[0].wholeText.length));\n  }\n  return range;\n}\n\nexport function fragmentToRangeList(fragment: string): Range[] {\n  return fragment.substring(1).split(',').map(getRangeFromFragmentPart);\n}\n","import * as v2 from './versions/2';\n\nfunction selectRanges(ranges: Range[]) {\n  const selection = document.getSelection() as Selection;\n  selection.removeAllRanges();\n  for (const range of ranges) {\n    selection.addRange(range);\n  }\n  ranges[0].startContainer.parentElement?.scrollIntoView();\n  if (selection.rangeCount != ranges.length) {\n    void import('./e').then(error => error.m(ranges));\n  }\n}\n\nvoid (async () => {\n  const fragment = location.hash.slice(1);\n\n  if (fragment && !document.getElementById(fragment)) {\n    if (fragment[0] == '1') {\n      const v1 = await import('./versions/1');\n      selectRanges(v1.fragmentToRangeList(fragment));\n    } else if (fragment[0] == '2') {\n      selectRanges(v2.fragmentToRangeList(fragment));\n    }\n  }\n\n  // This is in a setTimeout to ensure that the code above does all of its\n  // selection-changing before this executes. This ensures that we don't\n  // clobber changes that we just made (for instance, in the case of a user\n  // on Chrome attempting to open a multiselect url).\n  //\n  // This also allows us to make more careful decisions about rewriting urls\n  // in general — we can explicitly decide when and how to do version bumps,\n  // for instance.\n  setTimeout(() => {\n    document.addEventListener('selectionchange', () => {\n      const fragment = v2.selectionToFragment(document.getSelection() as Selection);\n      // replaceState is used instead of setting location.hash to avoid scrolling.\n      history.replaceState(null, '', location.pathname + fragment);\n    });\n  }, 0);\n})();\n\n"],"names":["_rixits","fromNumber","number","isNaN","Infinity","rixit","result","Math","floor","charAt","toNumber","string","rixits","split","e","length","indexOf","cyrb53","str","h1","h2","ch","i","charCodeAt","imul","hashNode","n","wholeText","trim","countLeadingWhitespace","node","trimStart","normalizeRange","range","makeNodeAndOffset","initNode","initOffset","offset","nodeType","childNodes","min","startNode","startOffset","startContainer","endNode","endOffset","endContainer","newRange","Range","treeWalker","document","createTreeWalker","commonAncestorContainer","stage","currentNode","prevEndNode","nextNode","setStart","setEnd","getRangeFromFragmentPart","fragmentPart","hashOffsetFragmentPart","dupeString","dupeStartOffset","dupeEndOffset","map","x","startHash","endHash","nodes","walk","body","numEndNodes","hash","push","join","anchorNodeType","anchorNodeIndex","findIndex","selectRanges","ranges","selection","getSelection","removeAllRanges","addRange","parentElement","scrollIntoView","rangeCount","import","then","error","m","fragment","location","slice","getElementById","fragmentToRangeList","substring","v2.fragmentToRangeList","setTimeout","addEventListener","getRangeAt","collapsed","max","dupes","startDupeOffset","endDupeOffset","Set","size","v2.selectionToFragment","history","replaceState","pathname"],"mappings":"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"}