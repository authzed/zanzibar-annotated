import { Column, Header, Page } from '../components/layout';
import PageFooter from '../components/PageFooter';

<Page>

<Header>

# Zanzibar: Google's Consistent, Global Authorization System

<div className="text-center mb-20">

<p className="text-lg leading-2">Ruoming Pang, Ramon Caceres, Mike Burrows, Zhifeng Chen, Pratik Dave, Nathan Germer, Alexander Golynski, Kevin Graney, Nina Kang, Lea Kissnerm Jeffrey L. Korn, Abhishek Parmar, Christina D. Richards, Mengzhi Wang</p>

<p>Google, LLC; Humu, Inc.; Carbon, Inc.</p>

<p>\{rpang, caceres\}@google.com</p>

</div>

</Header>

<Column>

## Abstract

Determining whether online users are authorized to access digital objects is central to preserving privacy.
This paper presents the design, implementation, and deployment of Zanzibar, a global system for storing and evaluating access control lists.
Zanzibar provides a uniform data model and configuration language for expressing a wide range of access control policies from hundreds of client services at Google, including Calendar, Cloud, Drive, Maps, Photos, and YouTube.
Its authorization decisions respect causal ordering of user actions and thus provide external consistency amid changes to access control lists and object contents.
Zanzibar scales to trillions of access control lists and millions of authorization requests per second to support services used by billions of people.
It has maintained 95th-percentile latency of less than 10 milliseconds and availability of greater than 99.999% over 3 years of production use.

## 1 Introduction

Many online interactions require authorization checks to confirm that a user has permission to carry out an operation on a digital object.
For example, web-based photo storage services typically allow photo owners to share some photos with friends while keeping other photos private.
Such a service must check whether a photo has been shared with a user before allowing that user to view the photo.
Robust authorization checks are central to preserving online privacy.

This paper presents Zanzibar, a system for storing permissions and performing authorization checks based on the stored permissions.
It is used by a wide array of services offered by Google, including Calendar, Cloud, Drive, Maps, Photos, and YouTube.
Several of these services manage billions of objects on behalf of more than a billion users.

A unified authorization system offers important advantages over maintaining separate access control mechanisms for individual applications.
First, it helps establish consistent

</Column>
<Column>

semantics and user experience across applications.
Second, it makes it easier for applications to interoperate, for example, to coordinate access control when an object from one application embeds an object from another application.
Third, useful common infrastructure can be built on top of a unified access control system, in particular, a search index that respects access control and works across applications.
Finally, as we show below, authorization poses unique challenges involving data consistency and scalability.
It saves engineering resources to tackle them once across applications.

We have the following goals for the Zanzibar system:

- _Correctness_: It must ensure consistency of access control decisions to respect user intentions.
- _Flexibility_: It must support a rich set of access control policies as required by both consumer and enterprise applications.
- _Low latency_: It must respond quickly because authorization checks are often in the critical path of user interactions. Low latency at the tail is particularly important for serving search results, which often require tens to hundreds of checks.
- _High availability_: It must reliably respond to requests because, in the absence of explicit authorizations, client services would be forced to deny their users access.
- _Large scale_: It needs to protect billions of objects shared by billions of users. It must be deployed around the globe to be near its clients and their end users.

Zanzibar achieves these goals through a combination of notable features.
To provide flexibility, Zanzibar pairs a simple data model with a powerful configuration language.
The language allows clients to define arbitrary relations between users and objects, such as owner, editor, commenter, and viewer.
It includes set-algebraic operators such as intersection and union for specifying potentially complex access control policies in terms of those user-object relations.
For example, an application can specify that users granted editing rights on a document are also allowed to comment on the

</Column>

<PageFooter numberLabel="1" />
</Page>


<Page>
<Column>

document, but not all commenters are given editing rights.

At runtime, Zanzibar allows clients to create, modify, and evaluate access control lists (ACLs) through a remote procedure call (RPC) interface.
A simple ACL takes the form of "user `U` has relation `R` to object `O`".
More complex ACLs take the form of "set of users `S` has relation `R` to object `O`", where `S` is itself specified in terms of another object-relation pair.
ACLs can thus refer to other ACLs, for example to specify that the set of users who can comment on a video consists of the users who have been granted viewing rights on that specific video along with those with viewing permissions on the video channel.

Group memberships are an important class of ACL where the object is a group and the relation is semantically equivalent to member.
Groups can contain other groups, which illustrates one of the challenges facing Zanzibar, namely that evaluating whether a user belongs to a group can entail following a long chain of nested group memberships.

Authorization checks take the form of "does user `U` have relation `R` to object `O`?" and are evaluated by a collection of distributed servers.
When a check request arrives to Zanzibar, the work to evaluate the check may fan out to multiple servers, for example when a group contains both individual members and other groups.
Each of those servers may in turn contact other servers, for example to recursively traverse a hierarchy of group memberships.

Zanzibar operates at a global scale along multiple dimensions.
It stores more than two trillion ACLs and performs millions of authorization checks per second.
The ACL data does not lend itself to geographic partitioning because authorization checks for any object can come from anywhere in the world.
Therefore, Zanzibar replicates all ACL data in tens of geographically distributed data centers and distributes load across thousands of servers around the world.

Zanzibar supports global consistency of access control decisions through two interrelated features.
One, it respects the order in which ACL changes are committed to the underlying data store.
Two, it can ensure that authorization checks are based on ACL data no older than a client-specified change.
Thus, for example, a client can remove a user from a group and be assured that subsequent membership checks reflect that removal.
Zanzibar provides these ordering properties by storing ACLs in a globally distributed database system with external consistency guarantees. [^15] [^18]

Zanzibar employs an array of techniques to achieve low latency and high availability in this globally distributed environment.
Its consistency protocol allows the vast majority of requests to be served with locally replicated data, without requiring cross-region round trips.
Zanzibar stores its data in normalized forms for consistency.
It handles hot spots on normalized data by caching final and intermediate results, and by deduplicating simultaneous requests.
It also applies techniques such as hedging requests and optimizing computations on deeply nested sets with limited denormal-

</Column>
<Column>

ization.
Zanzibar responds to more than 95% of authorization checks within 10 milliseconds and has maintained more than 99.999% availability for the last 3 years.

The main contributions of this paper lie in conveying the engineering challenges in building and deploying a consistent, world-scale authorization system.
While most elements of Zanzibar's design have their roots in previous research, this paper provides a record of the features and techniques Zanzibar brings together to satisfy its stringent requirements for correctness, flexibility, latency, availability, and scalability.
The paper also highlights lessons learned from operating Zanzibar in service of a diverse set of demanding clients.

## 2 Model, Language, and API

This section describes Zanzibar's data model, configuration language, and application programming interface (API).

### 2.1 Relation Tuples

In Zanzibar, ACLs are collections of object-user or object-object relations represented as _relation tuples_.
Groups are simply ACLs with membership semantics.
Relation tuples have efficient binary encodings, but in this paper we represent them using a convenient text notation:

```
〈tuple〉  ::= 〈object〉'#'〈relation〉'@'〈user〉
〈object〉 ::= 〈namespace〉':'〈object id〉
〈user〉   ::= 〈user id〉 | 〈userset〉
〈userset〉::= 〈object〉'#'〈relation〉
```

where `〈namespace〉` and `〈relation〉` are predefined in client configurations [(§2.3)](#2.3-namespace-configuration), `〈object id〉` is a string, and `〈user id〉` is an integer.
The primary keys required to identify a relation tuple are `〈namespace〉`, `〈object id〉`, `〈relation〉`, and `〈user〉`.
One feature worth noting is that a `〈userset〉` allows ACLs to refer to groups and thus supports representing nested group membership.

Table 1 shows some example tuples and corresponding semantics.
While some relations (e.g. viewer) define access control directly, others (e.g. parent, pointing to a folder) only define abstract relations between objects.
These abstract relations may indirectly affect access control given userset rewrite rules specified in namespace configs [§2.3.1][2-3-1-Relation-Configs-and-Userset-Rewrites].
Defining our data model around tuples, instead of per-object ACLs, allows us to unify the concepts of ACLs and groups and to support efficient reads and incremental updates, as we will see in [§2.4][2-4-api].

Defining our data model around tuples, instead of per- object ACLs, allows us to unify the concepts of ACLs and groups and to support efficient reads and incremental up- dates, as we will see in §2.4.

### 2.2 Consistency Model

ACL checks must respect the order in which users modify ACLs and object contents to avoid unexpected sharing be- haviors. Specifically, our clients care about preventing the

</Column>

<PageFooter numberLabel="2" />

</Page>


<Page>

<div className="w-3/4 col-span-2 mx-auto text-left">

| Example Tuple in Text Notation | Semantics |
| ------------------------------ | --------- |
| doc:readme#owner@10            | User 10 is an owner of doc:readme |
| group:eng#member@11            | User 11 is a member of group:eng |
| doc:readme#viewer@group:eng#member | Members of group:eng are viewers of doc:readme |
| doc:readme#parent@folder:A#... | doc:readme is in folder:A |

<p className="indent-0  mb-20">_Table 1: Example relation tuples** "#..." represents a relation that does not affect the semantics of the tuple._</p>

</div>

<Column>

“new enemy” problem, which can arise when we fail to respect the ordering between ACL updates or when we apply old ACLs to new content.

Consider these two examples:

<a name="example-a"></a>

**Example A: Neglecting ACL update order**

1. Alice removes Bob from the ACL of a folder;
2. Alice then asks Charlie to move new documents to the folder, where document ACLs inherit from folder ACLs;
3. Bob should not be able to see the new documents, but may do so if the ACL check neglects the ordering between the two ACL changes.

<a name="example-b"></a>

**Example B: Misapplying old ACL to new content**

1. Alice removes Bob from the ACL of a document;
2. Alice then asks Charlie to add new contents to the document;
3. Bob should not be able to see the new contents, but may do so if the ACL check is evaluated with a stale ACL from before Bob's removal.

Preventing the "new enemy" problem requires Zanzibar to understand and respect the causal ordering between ACL or content updates, including updates on different ACLs or objects and those coordinated via channels invisible to Zanzibar.
Hence Zanzibar must provide two key consistency properties: external consistency [^18] and snapshot reads with bounded staleness.

External consistency allows Zanzibar to assign a timestamp to each ACL or content update, such that two causally related updates $x \prec y$ will be assigned timestamps that reflect the causal order: $T_x \lt T_y$.
With causally meaningful timestamps, a snapshot read of the ACL database at timestamp $T$, which observes all updates with timestamps $\leq T$, will respect ordering between ACL updates.
That is, if the read observes an update $x$, it will observe all updates that happen causally before $x$.

Furthermore, to avoid applying old ACLs to new contents, the ACL check evaluation snapshot must not be staler than the causal timestamp assigned to the content update.
Given a content update at timestamp $T_c$, a snapshot read at timestamp

</Column>
<Column>

$\geq T_c$ ensures that all ACL updates that happen causally before the content update will be observed by the ACL check.

To provide external consistency and snapshot reads with bounded staleness, we store ACLs in the Spanner global database system[^15].
Spanner's TrueTime mechanism assigns each ACL write a microsecond-resolution timestamp, such that the timestamps of writes reflect the causal ordering between writes, and thereby provide external consistency.
We evaluate each ACL check at a single snapshot timestamp across multiple database reads, so that all writes with timestamps up to the check snapshot, and only those writes, are visible to the ACL check.

To avoid evaluating checks for new contents using stale ACLs, one could try to always evaluate at the latest snapshot such that the check result reflects all ACL writes up to the check call.
However, such evaluation would require global data synchronization with high-latency round trips and limited availability.
Instead, we design the following protocol to allow most checks to be evaluated on already replicated data with cooperation from Zanzibar clients:

1. A Zanzibar client requests an opaque consistency token called a zookie for each content version, via a content- change ACL check (§2.4.4) when the content modification is about to be saved.
Zanzibar encodes a current global timestamp in the zookie and ensures that all prior ACL writes have lower timestamps.
The client stores the zookie with the content change in an atomic write to the client storage.
Note that the content-change check does not need to be evaluated in the same transaction as the application content modification, but only has to be triggered when the user modifies the contents.
2. The client sends this zookie in subsequent ACL check requests to ensure that the check snapshot is at least as fresh as the timestamp for the content version.

External consistency and snapshot reads with staleness bounded by zookie prevent the "new enemy" problem.
In [Example A](#example-a), ACL updates $A1$ and $A2$ will be assigned timestamps $T_{A1} \leq T_{A2}$, respectively.
Bob will not be able to see the new documents added by Charlie: if a check is evaluated at $T \leq T_{A2}$, the document ACLs will not include the folder ACL; if a check is evaluated at $T \geq T_{A2} \gt T_{A1}$, the check will observe update $A1$, which removed Bob from the
</Column>

<PageFooter numberLabel="3" />

</Page>



<Page>
<Column>
</Column>
<Column>
</Column>
<PageFooter numberLabel="x" />
</Page>

